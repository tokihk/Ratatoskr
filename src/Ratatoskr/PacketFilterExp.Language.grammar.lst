
// ==========================================================================
//  GPPG error listing for yacc source file <Scripts\PacketFilterExp\Parser\PacketFilterExp.Language.grammar.y - 2017/09/01 20:12:25>
// ==========================================================================
//  Version:  1.5.2
//  Machine:  KPC-2456
//  DateTime: 2017/09/01 20:12:27
//  UserName: i32719
// ==========================================================================


// http://www.quut.com/c/ANSI-C-grammar-y.html
// http://www.quut.com/c/ANSI-C-grammar-l-2011.html

%using System.Diagnostics;

%namespace Ratatoskr.Scripts.PacketFilterExp.Parser

%visibility internal
%parsertype ExpressionParser

%{
    private ExpressionObject exp_ = new ExpressionObject();
%}

%union {
	public Terms.Term term;
}

%token	<term>VALUE_BOOL VALUE_NUMBER VALUE_TEXT VALUE_BINARY VALUE_REGEX VALUE_DATETIME VALUE_DATETIMEOFFSET

%token	ARMOP_SET ARMOP_NEG

%token	ARMOP_ADD ARMOP_SUB ARMOP_MUL ARMOP_DIV ARMOP_REM

%token 	RELOP_GREATER RELOP_LESS RELOP_GREATEREQUAL RELOP_LESSEQUAL

%token	RELOP_EQUAL RELOP_UNEQUAL

%token	LOGOP_AND LOGOP_OR

%%
// Error: NonTerminal symbol "LP" has no productions
// Error: NonTerminal symbol "RP" has no productions
// Error: NonTerminal symbol "VALUE_STATUS" has no productions
// Warning: Terminating VALUE_STATUS fixes the following size-1 NonTerminal set
   // {VALUE_STATUS}
// Error: There are 3 non-terminating NonTerminal Symbols
   //  {LP, RP, VALUE_STATUS}
// Warning: Terminating LP fixes the following size-1 NonTerminal set
   // {LP}
// Warning: Terminating RP fixes the following size-1 NonTerminal set
   // {RP}
// ----------------------------------------------------------------------------


expression
	: assignment_expression
	;

assignment_expression
	: logical_expression
	| logical_expression ARMOP_SET logical_expression
	{
		exp_.Add(Tokens.ARMOP_SET);
	}
	;

logical_expression
	: equality_expression
	| equality_expression LOGOP_OR equality_expression
	{
		exp_.Add(Tokens.LOGOP_OR);
	}
	| equality_expression LOGOP_AND equality_expression
	{
		exp_.Add(Tokens.LOGOP_AND);
	}
	;

equality_expression
	: relational_expression
	| relational_expression RELOP_EQUAL relational_expression
	{
		exp_.Add(Tokens.RELOP_EQUAL);
	}
	| relational_expression RELOP_UNEQUAL relational_expression
	{
		exp_.Add(Tokens.RELOP_UNEQUAL);
	}
	;

relational_expression
	: additive_expression
	| additive_expression RELOP_GREATEREQUAL additive_expression
	{
		exp_.Add(Tokens.RELOP_GREATEREQUAL);
	}
	| relational_expression RELOP_LESSEQUAL additive_expression
	{
		exp_.Add(Tokens.RELOP_LESSEQUAL);
	}
	| relational_expression RELOP_GREATER additive_expression
	{
		exp_.Add(Tokens.RELOP_GREATER);
	}
	| relational_expression RELOP_LESS additive_expression
	{
		exp_.Add(Tokens.RELOP_LESS);
	}
	;

additive_expression
	: multiplicative_expression
	| multiplicative_expression ARMOP_ADD multiplicative_expression
	{
		exp_.Add(Tokens.ARMOP_ADD);
	}
	| multiplicative_expression ARMOP_SUB multiplicative_expression
	{
		exp_.Add(Tokens.ARMOP_SUB);
	}
	;

multiplicative_expression
	: negative_expression
	| negative_expression ARMOP_MUL negative_expression
	{
		exp_.Add(Tokens.ARMOP_MUL);
	}
	| negative_expression ARMOP_DIV negative_expression
	{
		exp_.Add(Tokens.ARMOP_DIV);
	}
	| negative_expression ARMOP_REM negative_expression
	{
		exp_.Add(Tokens.ARMOP_REM);
	}
	;

negative_expression
	: postfix_expression
	| ARMOP_NEG postfix_expression
	{
		exp_.Add(Tokens.ARMOP_NEG);
	}
	;

postfix_expression
	: primary_expression
	| primary_expression LP expression RP
	;

primary_expression
	: VALUE_BOOL
	{
		exp_.Add($1);
	}
	| VALUE_NUMBER
	{
		exp_.Add($1);
	}
	| VALUE_TEXT
	{
		exp_.Add($1);
	}
	| VALUE_BINARY
	{
		exp_.Add($1);
	}
	| VALUE_REGEX
	{
		exp_.Add($1);
	}
	| VALUE_DATETIME
	{
		exp_.Add($1);
	}
	| VALUE_DATETIMEOFFSET
	{
		exp_.Add($1);
	}
	| VALUE_STATUS
	{
		exp_.Add($1);
	}
	;

%%

    private ExpressionParser() : base(null) { }

    public static ExpressionObject Parse(string exp)
    {
         if (exp == null)return (null);
         if (exp.Length == 0)return (null);

         var scanner = new Scanner();

         scanner.SetSource(exp, 0);
         
         var parser = new ExpressionParser();
         
         parser.Scanner = scanner;
         
         if (!parser.Parse())return (null);
         
         return (parser.exp_);
    }
// ==========================================================================

