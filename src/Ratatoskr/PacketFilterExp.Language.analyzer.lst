
// ==========================================================================
//  GPLEX error listing for lex source file <PacketFilterExp.Language.analyzer.lex>
// ==========================================================================
//  Version:  1.2.2
//  Machine:  KPC-2456
//  DateTime: 2017/09/04 13:32:48
//  UserName: i32719
// ==========================================================================


// http://www.quut.com/c/ANSI-C-grammar-y.html
// http://www.quut.com/c/ANSI-C-grammar-l-2011.html

%using System.Diagnostics;
%using Ratatoskr.Generic

%visibility internal
//^^^^^^^^^
// Error: Unexpected symbol, skipping to  <%%> 
// Error: Parser error <Syntax error, unexpected %visibility, expecting ;, or .> 
// ------------------------------------------------------------------------------

%namespace Ratatoskr.Scripts.PacketFilterExp.Parser

%option noFiles

%{
public override void yyerror(string format, params object[] args)
{
//	Debug.WriteLine("Error: line {0} - " + format, yyline);
}
%}

O   [0-7]
D   [0-9]
NZ  [1-9]
L   [a-zA-Z_]
A   [a-zA-Z_0-9]
H   [a-fA-F0-9]
HP  (0[xX])
FS  (f|F|l|L)
IS  (((u|U)(l|L|ll|LL)?)|((l|L|ll|LL)(u|U)?))
CP  (u|U|L)
SP  (u8|u|U|L)
ES  ([a-fA-F0-9]+)
WS  [ \t\v\n\f]
TY  ([0-9]{4})
TM  ([0][0-9]|1[0-2])
TD  ([0-2][0-9]|3[0-1])
Th  ([0-1][0-9]|2[0-3])
Tm  ([0-5][0-9])
Ts  ([0-5][0-9])
Tf  ([0-9]{3})

%{

%}

%%

// --- (10i) --------------------------
<INITIAL>[0]|([1-9][0-9]*)(\.[0-9]+){0,1} {
	yylval.term = new Terms.Term_Number(double.Parse(yytext));
	return (int)Tokens.VALUE_NUMBER;
}

// --- (16i) --------------------------
<INITIAL>0[xX][0-9a-fA-F]{1,8} {
	yylval.term = new Terms.Term_Number((double)uint.Parse(yytext, System.Globalization.NumberStyles.HexNumber));
	return (int)Tokens.VALUE_NUMBER;
}

// --- oCizñ --------------------------
<INITIAL>[\[][0-9a-fA-F]+[\]] {
	yylval.term = new Terms.Term_Binary(HexTextEncoder.ToByteArray(yytext.Substring(1, yytext.Length - 2)));
	return (int)Tokens.VALUE_BINARY;
}

// --- (ISO8601) --------------------------
<INITIAL>{TY}-{TM}-{TD}T{Th}:{Tm}:{Ts}(\.{Tf})([\+\-]{Th}:{Tm}|Z) {
//--------^^
// Error: Unknown lexical category <TY> 
// -------------------------------------
	yylval.term = new Terms.Term_DateTime(yytext);
	return (int)Tokens.VALUE_DATETIME;
}

// --- (ItZbg) --------------------------
<INITIAL>{Th}:{Tm}:{Ts}(\.{Tf}) {
//--------^^
// Error: Unknown lexical category <Th> 
// -------------------------------------
	yylval.term = new Terms.Term_DateTimeOffset(yytext);
	return (int)Tokens.VALUE_DATETIMEOFFSET;
}

// --- ¶ñ ["xxx"] -------------------------
<INITIAL>\"[^\"]*\" {
	yylval.term = new Terms.Term_Text(yytext.Substring(1, yytext.Length - 2));
	return (int)Tokens.VALUE_TEXT;
}

// --- ³K\» -------------------------------
<INITIAL>\/[^/]*\/ {
	yylval.term = new Terms.Term_Regex(yytext.Substring(1, yytext.Length - 2));
	return (int)Tokens.VALUE_REGEX;
}

// --- Xe[^X -----------------------------
<INITIAL>PacketCount {
	yylval.term = new Terms.Term_Status(Terms.Term_Status.PacketCount);
	return (int)Tokens.VALUE_STATUS;
}
<INITIAL>LastDelta {
	yylval.term = new Terms.Term_Status(Terms.Term_Status.LastPacketDelta);
	return (int)Tokens.VALUE_STATUS;
}
<INITIAL>Control {
	yylval.term = new Terms.Term_Status(Terms.Term_Status.Packet_IsControl);
	return (int)Tokens.VALUE_STATUS;
}
<INITIAL>Message {
	yylval.term = new Terms.Term_Status(Terms.Term_Status.Packet_IsMessage);
	return (int)Tokens.VALUE_STATUS;
}
<INITIAL>Data {
	yylval.term = new Terms.Term_Status(Terms.Term_Status.Packet_IsData);
	return (int)Tokens.VALUE_STATUS;
}
<INITIAL>Alias {
	yylval.term = new Terms.Term_Status(Terms.Term_Status.Packet_Alias);
	return (int)Tokens.VALUE_STATUS;
}
<INITIAL>DateTime {
	yylval.term = new Terms.Term_Status(Terms.Term_Status.Packet_MakeTime);
	return (int)Tokens.VALUE_STATUS;
}
<INITIAL>Information {
	yylval.term = new Terms.Term_Status(Terms.Term_Status.Packet_Information);
	return (int)Tokens.VALUE_STATUS;
}
<INITIAL>Mark {
	yylval.term = new Terms.Term_Status(Terms.Term_Status.Packet_Mark);
	return (int)Tokens.VALUE_STATUS;
}
<INITIAL>Send {
	yylval.term = new Terms.Term_Status(Terms.Term_Status.Packet_Data_IsSend);
	return (int)Tokens.VALUE_STATUS;
}
<INITIAL>Recv {
	yylval.term = new Terms.Term_Status(Terms.Term_Status.Packet_Data_IsRecv);
	return (int)Tokens.VALUE_STATUS;
}
<INITIAL>Source {
	yylval.term = new Terms.Term_Status(Terms.Term_Status.Packet_Data_Source);
	return (int)Tokens.VALUE_STATUS;
}
<INITIAL>Destination {
	yylval.term = new Terms.Term_Status(Terms.Term_Status.Packet_Data_Destination);
	return (int)Tokens.VALUE_STATUS;
}
<INITIAL>DataSize {
	yylval.term = new Terms.Term_Status(Terms.Term_Status.Packet_Data_Length);
	return (int)Tokens.VALUE_STATUS;
}
<INITIAL>BitText {
	yylval.term = new Terms.Term_Status(Terms.Term_Status.Packet_Data_BitText);
	return (int)Tokens.VALUE_STATUS;
}
<INITIAL>HexText {
	yylval.term = new Terms.Term_Status(Terms.Term_Status.Packet_Data_HexText);
	return (int)Tokens.VALUE_STATUS;
}
<INITIAL>AsciiText {
	yylval.term = new Terms.Term_Status(Terms.Term_Status.Packet_Data_AsciiText);
	return (int)Tokens.VALUE_STATUS;
}
<INITIAL>Utf8Text {
	yylval.term = new Terms.Term_Status(Terms.Term_Status.Packet_Data_Utf8Text);
	return (int)Tokens.VALUE_STATUS;
}
<INITIAL>UnicodeLText {
	yylval.term = new Terms.Term_Status(Terms.Term_Status.Packet_Data_UnicodeLText);
	return (int)Tokens.VALUE_STATUS;
}
<INITIAL>UnicodeBText {
	yylval.term = new Terms.Term_Status(Terms.Term_Status.Packet_Data_UnicodeBText);
	return (int)Tokens.VALUE_STATUS;
}

<INITIAL>"="  { return (int)Tokens.ARMOP_SET;      }
<INITIAL>"+"  { return (int)Tokens.ARMOP_ADD;      }
<INITIAL>"-"  { return (int)Tokens.ARMOP_SUB;      }
<INITIAL>"*"  { return (int)Tokens.ARMOP_MUL;      }
<INITIAL>"/"  { return (int)Tokens.ARMOP_SUB;      }
<INITIAL>"%"  { return (int)Tokens.ARMOP_REM;      }
<INITIAL>"!"  { return (int)Tokens.ARMOP_NEG;      }

<INITIAL>">"  { return (int)Tokens.RELOP_GREATER;      }
<INITIAL>"<"  { return (int)Tokens.RELOP_LESS;         }
<INITIAL>">=" { return (int)Tokens.RELOP_GREATEREQUAL; }
<INITIAL>"<=" { return (int)Tokens.RELOP_LESSEQUAL;    }

<INITIAL>"==" { return (int)Tokens.RELOP_EQUAL;   }
<INITIAL>"!=" { return (int)Tokens.RELOP_UNEQUAL; }

<INITIAL>"&&" { return (int)Tokens.LOGOP_AND; }
<INITIAL>"||" { return (int)Tokens.LOGOP_OR;  }

<INITIAL>"(" { return (int)Tokens.LP; }
<INITIAL>")" { return (int)Tokens.RP; }

<INITIAL>{WS} { }
//--------^^
// Error: Unknown lexical category <WS> 
// -------------------------------------

<INITIAL>. { return (int)Tokens.error; }

%%// ==========================================================================

